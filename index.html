<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Rese√±as G√ºerr√≠n</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #dc143c 0%, #8B0000 100%);
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        .banner {
            width:100%;
            height:180px;
            background: #eee url('banner.jpg') center/cover no-repeat;
            border-radius:12px;
            margin-bottom:22px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }
        h1 {
            color: #dc143c;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(255,215,0,0.3);
        }
        .subtitle { text-align:center; color:#666; margin-bottom:30px; font-size:1.1em; }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: linear-gradient(135deg, #dc143c 0%, #FFD700 100%);
            color: black;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(220,20,60,0.4);
        }
        .stat-label { font-size: 0.9em; opacity: 0.9; margin-bottom: 5px; }
        .stat-value { font-size: 2em; font-weight: bold; }

        .filters { background:#f8f9fa; padding:20px; border-radius:10px; margin-bottom:30px; }
        .filter-group { margin-bottom:15px; }
        .filter-group label { display:block; margin-bottom:5px; font-weight:600; color:#333; }

        .range-wrap {
            position: relative;
            height: 28px;
            margin-top: 6px;
        }
        .range-wrap input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            position: absolute;
            left: 0;
            right: 0;
            top: 6px;
            width: 100%;
            background: transparent;
            pointer-events: none;
        }
        .range-track {
            position: absolute;
            left: 0;
            right: 0;
            top: 16px;
            height: 6px;
            background: linear-gradient(90deg,#ffd700 0%, #ff073a 100%);
            border-radius: 6px;
            opacity: 0.25;
        }
        .range-wrap input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            border: 3px solid #ff073a;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            pointer-events: auto;
        }
        .range-values { display:flex; justify-content:space-between; font-size:0.9em; color:#666; margin-top:28px; }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart-container {
            background:white;
            border-radius:10px;
            padding:20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border:1px solid #e0e0e0;
            min-height: 460px;
            display: flex;
            flex-direction: column;
        }
        #radarChart, #histChart, #palabrasChart, #temporalChart {
            min-height: 360px;
            width: 100%;
            flex: 1 1 auto;
        }
        .chart-title { font-size:1.2em; color:#333; margin-bottom:15px; padding-bottom:10px; border-bottom:2px solid #28a745; }
        .full-width { grid-column: 1 / -1; }
        
        .examples-section { margin-top:30px; }
        .comment-card { background:#f8f9fa; padding:15px; border-radius:8px; margin-bottom:15px; border-left:4px solid #28a745;border-right:4px solid #28a745; }
        /* Comentarios negativos (rojo como el bot√≥n negativo) */
                /* Asegurar que la clase 'negativo' cambie ambos bordes */
        .comment-card.negativo {
            border-left-color: #dc3545 !important;
            border-right-color: #dc3545 !important;
        }


        .comment-header { display:flex; justify-content:space-between; margin-bottom:10px; font-weight:600; }
        .comment-text { color:#555; line-height:1.6; }
        .comment-meta { font-size:0.9em; color:#888; margin-top:8px; }

        .random-buttons { display:flex; gap:12px; margin-top:18px; margin-bottom:18px; }
        .btn { padding:10px 14px; border-radius:8px; border:none; cursor:pointer; font-weight:600; }
        .btn-positive { background:#28a745; color:white; }
        .btn-negative { background:#dc3545; color:white; }

        .loading { text-align:center; padding:40px; color:#667eea; font-size:1.2em; }
        .hidden { display:none; }

        @media (max-width:480px){
            .range-wrap input[type="range"]::-webkit-slider-thumb { width:14px; height:14px; border-width:2px; }
            .chart-container { min-height: 380px; }
            #radarChart, #histChart, #palabrasChart, #temporalChart { min-height: 280px; }
            .random-buttons { flex-direction:column; }
        }
       
    </style>
</head>
<body>
    <div class="container">
        <div class="banner" aria-hidden="true"></div>

        <h1> Dashboard de Rese√±as G√ºerr√≠n</h1>
        <p class="subtitle">An√°lisis interactivo de opiniones de clientes</p>

        <div id="content" class="hidden">
            <div class="stats-grid">
                <div class="stat-card"><div class="stat-label">Rese√±as Neutrales / Total</div><div class="stat-value" id="cantidadNeutrales">0</div></div>
                <div class="stat-card"><div class="stat-label">Rese√±as Negativas / Total</div><div class="stat-value" id="ratioNegPos">0.00</div></div>
                <div class="stat-card"><div class="stat-label">Puntuaci√≥n Promedio</div><div class="stat-value" id="promedioScore">0.0</div></div>
                <div class="stat-card"><div class="stat-label">Rese√±as Mostradas</div><div class="stat-value" id="filtradas">0</div></div>
            </div>

            <div class="filters">
                <div class="filter-group">
                    <label>üîç Filtrar por Puntuaci√≥n</label>
                    <div class="range-wrap" aria-hidden="false">
                        <div class="range-track" id="rangeTrack"></div>
                        <input type="range" id="rangeMin" min="1" max="5" step="1" value="1" aria-label="Puntuaci√≥n m√≠nima">
                        <input type="range" id="rangeMax" min="1" max="5" step="1" value="5" aria-label="Puntuaci√≥n m√°xima">
                    </div>
                    <div class="range-values">
                        <span>M√≠nimo: <strong id="minScoreVal">1</strong></span>
                        <span>M√°ximo: <strong id="maxScoreVal">5</strong></span>
                    </div>
                </div>
            </div>

            <div class="charts-grid">
                <div class="chart-container"><div class="chart-title">üìà Promedios por Categor√≠a</div><div id="radarChart"></div></div>
                <div class="chart-container"><div class="chart-title">üìä Distribuci√≥n de Puntuaciones</div><div id="histChart"></div></div>
            </div>

            <div class="chart-container full-width"><div class="chart-title">üí¨ An√°lisis de Comentarios</div><div id="palabrasChart"></div></div>
            <div class="chart-container full-width"><div class="chart-title">üìÖ Evoluci√≥n Temporal</div><div id="temporalChart"></div></div>

            <div class="examples-section">
                <h2 style="color: #667eea; margin-bottom: 20px;">üìù Ejemplos de Comentarios</h2>

                <!-- botones para comentarios aleatorios -->
                <div class="random-buttons">
                    <button id="randomPosBtn" class="btn btn-positive">üé≤ 3 positivos aleatorios (‚â•4)</button>
                    <button id="randomNegBtn" class="btn btn-negative">üé≤ 3 negativos aleatorios (‚â§2)</button>
                </div>

                <div id="randomPosContainer"></div>
                <div id="randomNegContainer"></div>

                <div id="ejemplosPositivos"></div>
                <div id="ejemplosNegativos"></div>
            </div>
        </div>

        <div id="loading" class="loading">Cargando y procesando datos...</div>
    </div>

    <script>
        let dataGlobal = [];

        // Plotly: solo toImage
        const plotlyConfig = { responsive: true, displaylogo: false, modeBarButtons: [['toImage']] };

        const tryFiles = ["rese√±as_juntas1.csv"];
        const loadCsvAttempts = async () => {
            for (let name of tryFiles) {
                try {
                    const resp = await fetch(name);
                    if (!resp.ok) continue;
                    const txt = await resp.text();

                    const lines = txt.split(/\r?\n/).filter(l => l.trim().length > 0);
                    let delimiter = ",";
                    if (lines.length > 1) {
                        const headerLine = lines[0];
                        const semis = (headerLine.match(/;/g) || []).length;
                        const comms = (headerLine.match(/,/g) || []).length;
                        if (semis > comms) delimiter = ";";
                    }

                    Papa.parse(txt, {
                        header: true,
                        skipEmptyLines: true,
                        delimiter: delimiter,
                        complete: function(results) {
                            dataGlobal = results.data.filter(row =>
                                Object.values(row).some(v => v !== null && v !== undefined && String(v).trim() !== "")
                            );
                            if (dataGlobal.length === 0) {
                                document.getElementById('loading').textContent = "El archivo se carg√≥ pero no tiene filas √∫tiles.";
                                return;
                            }
                            document.getElementById('loading').classList.add('hidden');
                            document.getElementById('content').classList.remove('hidden');

                            procesarDatos();
                            updateRangeUI();
                        },
                        error: function(err) {
                            console.error("PapaParse error:", err);
                            document.getElementById('loading').textContent = "Error al parsear " + name;
                        }
                    });
                    return;
                } catch (e) {
                    console.warn("No se pudo cargar", name, e);
                    continue;
                }
            }
            document.getElementById('loading').textContent =
                "No se encontr√≥ ninguno de los archivos esperados (rese√±as.csv / resenas.csv / rese√±as.txt / resenas.txt). " +
                "Asegurate que el CSV est√© en la misma carpeta que el HTML y que Live Server est√© sirviendo esa carpeta.";
        };

        window.addEventListener("load", () => { loadCsvAttempts(); });

        // slider dual
        const minHandle = document.getElementById('rangeMin');
        const maxHandle = document.getElementById('rangeMax');
        const minValEl = document.getElementById('minScoreVal');
        const maxValEl = document.getElementById('maxScoreVal');
        const trackEl = document.getElementById('rangeTrack');

        function clampHandles() {
            let min = parseInt(minHandle.value, 10);
            let max = parseInt(maxHandle.value, 10);
            if (min > max) {
                if (this === minHandle) maxHandle.value = min;
                else minHandle.value = max;
                min = parseInt(minHandle.value,10);
                max = parseInt(maxHandle.value,10);
            }
            minValEl.textContent = min;
            maxValEl.textContent = max;

            const range = parseInt(minHandle.max,10) - parseInt(minHandle.min,10);
            const leftPerc = ((min - parseInt(minHandle.min,10)) / range) * 100;
            const rightPerc = ((max - parseInt(minHandle.min,10)) / range) * 100;
            trackEl.style.background = `linear-gradient(90deg, rgba(0,0,0,0.05) ${leftPerc}%, rgba(255,215,0,0.9) ${leftPerc}%, rgba(255,7,58,0.9) ${rightPerc}%, rgba(0,0,0,0.05) ${rightPerc}%)`;
        }

        minHandle.addEventListener('input', function() {
            if (parseInt(this.value,10) > parseInt(maxHandle.value,10)) {
                maxHandle.value = this.value;
            }
            clampHandles.call(this);
            actualizarGraficos();
        });
        maxHandle.addEventListener('input', function() {
            if (parseInt(this.value,10) < parseInt(minHandle.value,10)) {
                minHandle.value = this.value;
            }
            clampHandles.call(this);
            actualizarGraficos();
        });

        // --- procesamiento y m√©tricas ---
        function procesarDatos() {
            // conservar solo filas con Puntuaci√≥n v√°lida
            dataGlobal = dataGlobal.filter(row => row["Puntuaci√≥n"] && String(row["Puntuaci√≥n"]).trim() !== '');
            dataGlobal.forEach(row => {
                row.Puntuaci√≥n = parseFloat(row["Puntuaci√≥n"]) || 0;
                row.Comida = parseFloat(row["Comida"]) || 0;
                row.Servicio = parseFloat(row["Servicio"]) || 0;
                row.Ambiente = parseFloat(row["Ambiente"]) || 0;
            });

            // NOTA: ahora las estad√≠sticas se calculan sobre el conjunto filtrado
            actualizarGraficos();
        }

        // ahora acepta un conjunto de datos (filtrado) para calcular m√©tricas
        function actualizarEstadisticas(data = dataGlobal) {
            const neutralCount = data.filter(r => Math.round(r.Puntuaci√≥n) === 3).length;
            const negatives = data.filter(r => r.Puntuaci√≥n < 3).length;
            const total = data.length;
            const promedio = total ? (data.reduce((sum, row) => sum + row.Puntuaci√≥n, 0) / total) : 0;

            const neutralRatio = total > 0 ? ((neutralCount / total) * 100).toFixed(2) : 0;
            const negativeRatio = total > 0 ? ((negatives / total) * 100).toFixed(2) : 0;

            document.getElementById('cantidadNeutrales').textContent = `${neutralCount}/${total} (${neutralRatio}%)`;
            document.getElementById('promedioScore').textContent = promedio.toFixed(2);
            document.getElementById('ratioNegPos').textContent = `${negatives}/${total} (${negativeRatio}%)`;
        }

        function filtrarDatos() {
            const minScore = parseInt(document.getElementById("rangeMin").value, 10);
            const maxScore = parseInt(document.getElementById("rangeMax").value, 10);

            return dataGlobal.filter(row =>
                row.Puntuaci√≥n >= minScore && row.Puntuaci√≥n <= maxScore
            );
        }

        function actualizarGraficos() {
            const dataFiltrada = filtrarDatos();
            document.getElementById('filtradas').textContent = dataFiltrada.length;

            // actualizar ESTADISTICAS en funci√≥n del filtro actual
            actualizarEstadisticas(dataFiltrada);

            crearRadarChart(dataFiltrada);
            crearHistograma(dataFiltrada);
            crearGraficoPalabras(dataFiltrada);
            crearGraficoTemporal(dataFiltrada);
            mostrarEjemplos(dataFiltrada);
        }

        // ---------- helpers de fecha: parsear a Date y devolver YYYY-MM ----------
        function pad2(n){ return n<10 ? '0'+n : ''+n; }

        function parseFechaToDate(fechaRaw){
            if(!fechaRaw) return null;
            const s = String(fechaRaw).trim().toLowerCase();

            // si contiene "hace" o formatos relativos
            const relRegex = /\b(hace\s*)?(\d+|un|una|medio)\s*(a√±os|ano|a√±os|a√±o|meses|mes|semanas|semana|dias|d√≠as|dia|d√≠a)\b/;
            const relMatch = s.match(relRegex);
            if(relMatch){
                let numStr = relMatch[2];
                let n;
                if(numStr === 'un' || numStr === 'una') n = 1;
                else if(numStr === 'medio') n = 0.5;
                else n = parseFloat(numStr);
                const unit = relMatch[3];
                const now = new Date();

                if(unit.includes('a√±o') || unit.includes('ano') || unit.includes('a√±os')){
                    const d = new Date(now);
                    d.setFullYear(d.getFullYear() - Math.floor(n));
                    if(n % 1 !== 0){
                        d.setMonth(d.getMonth() - Math.round((n % 1) * 12));
                    }
                    return d;
                }
                if(unit.includes('mes')){
                    const d = new Date(now);
                    d.setMonth(d.getMonth() - Math.round(n));
                    return d;
                }
                if(unit.includes('semana')){
                    const d = new Date(now);
                    d.setDate(d.getDate() - Math.round(n * 7));
                    return d;
                }
                if(unit.includes('dia') || unit.includes('d√≠as') || unit.includes('dias')){
                    const d = new Date(now);
                    d.setDate(d.getDate() - Math.round(n));
                    return d;
                }
            }

            // casos "hace mes" (sin n√∫mero)
            if(/\bhace\s+mes(es)?\b/.test(s)) {
                const d = new Date();
                d.setMonth(d.getMonth() - 1);
                return d;
            }
            if(/\bhace\s+a√±o(s)?\b|\bhace\s+ano(s)?\b/.test(s)) {
                const d = new Date();
                d.setFullYear(d.getFullYear() - 1);
                return d;
            }
            if(/\bhace\s+semana(s)?\b/.test(s)) {
                const d = new Date();
                d.setDate(d.getDate() - 7);
                return d;
            }

            // ISO YYYY-MM or YYYY-MM-DD
            const isoMatch = s.match(/^(\d{4})-(\d{2})(?:-(\d{2}))?/);
            if(isoMatch){
                const y = parseInt(isoMatch[1],10);
                const m = parseInt(isoMatch[2],10) - 1;
                const d = isoMatch[3] ? parseInt(isoMatch[3],10) : 1;
                return new Date(y,m,d);
            }

            // formatos dd/mm/yyyy or dd-mm-yyyy
            const dmY = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
            if(dmY){
                let day = parseInt(dmY[1],10);
                let month = parseInt(dmY[2],10) - 1;
                let year = parseInt(dmY[3],10);
                if(year < 100) year += 2000;
                return new Date(year, month, day);
            }

            // si la cadena es solo "enero 2023" u "ene 2023" (manejo b√°sico meses en espa√±ol)
            const mesesEsp = {
                'enero':1,'ene':1,'febrero':2,'feb':2,'marzo':3,'mar':3,'abril':4,'abr':4,
                'mayo':5,'may':5,'junio':6,'jun':6,'julio':7,'jul':7,'agosto':8,'ago':8,
                'septiembre':9,'sep':9,'setiembre':9,'set':9,'octubre':10,'oct':10,
                'noviembre':11,'nov':11,'diciembre':12,'dic':12
            };
            const mesAnoMatch = s.match(/([a-z√°√©√≠√≥√∫√±]+)\s+(\d{4})/i);
            if(mesAnoMatch){
                const mesName = mesAnoMatch[1].toLowerCase();
                const year = parseInt(mesAnoMatch[2],10);
                if(mesesEsp[mesName]){
                    return new Date(year, mesesEsp[mesName]-1, 1);
                }
            }

            // si solo es YYYY
            const onlyYear = s.match(/^(\d{4})$/);
            if(onlyYear){
                return new Date(parseInt(onlyYear[1],10),0,1);
            }

            // fallback: intentar new Date() ‚Äî algunos formatos pueden parsear
            const fallback = new Date(fechaRaw);
            if(!isNaN(fallback.getTime())) return fallback;

            return null;
        }

        function dateToYYYYMM(d){
            if(!d) return null;
            const y = d.getFullYear();
            const m = pad2(d.getMonth()+1);
            return `${y}-${m}`;
        }

        function yyyymmToSpanishLabel(ym){
            // ym = "YYYY-MM"
            if(!ym) return ym;
            const parts = ym.split('-');
            if(parts.length !== 2) return ym;
            const y = parseInt(parts[0],10);
            const m = parseInt(parts[1],10);
            const nombres = ['Enero','Febrero','Marzo','Abril','Mayo','Junio','Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre'];
            const nombre = nombres[m-1] || parts[1];
            return `${nombre} ${y}`;
        }

        // ---------- Radar chart ----------
        function crearRadarChart(data) {
            const comidaVals = data.filter(r => r.Comida > 0).map(r => r.Comida);
            const servicioVals = data.filter(r => r.Servicio > 0).map(r => r.Servicio);
            const ambienteVals = data.filter(r => r.Ambiente > 0).map(r => r.Ambiente);

            const comida = comidaVals.length ? comidaVals.reduce((a,b)=>a+b,0)/comidaVals.length : 0;
            const servicio = servicioVals.length ? servicioVals.reduce((a,b)=>a+b,0)/servicioVals.length : 0;
            const ambiente = ambienteVals.length ? ambienteVals.reduce((a,b)=>a+b,0)/ambienteVals.length : 0;

            const traceMain = {
                type: 'scatterpolar',
                r: [comida, servicio, ambiente, comida],
                theta: ['Comida', 'Servicio', 'Ambiente', 'Comida'],
                fill: 'toself',
                line: { color: 'rgb(102,126,234)' },
                fillcolor: 'rgba(102,126,234,0.25)',
                hoverinfo: 'r+theta'
            };

            const layout = {
                polar: {
                    radialaxis: {
                        visible: true,
                        range: [1,5],
                        tickmode: 'array',
                        tickvals: [1,2,3,4,5],
                        ticktext: ['1','2','3','4','5'],
                        tickfont: { size: 12 },
                        gridcolor: '#ddd'
                    },
                    angularaxis: {
                        tickfont: { size: 13 }
                    }
                },
                showlegend: false,
                height: 400,
                margin: { t:40, b:40, l:40, r:40 }
            };

            Plotly.newPlot('radarChart', [traceMain], layout, plotlyConfig);
        }

        function crearHistograma(data) {
            const counts = [1,2,3,4,5].map(score => data.filter(r => Math.round(r.Puntuaci√≥n) === score).length);
            const colors = ['rgb(255,0,0)','rgb(255,165,0)','rgb(255,255,0)','rgb(144,238,144)','rgb(0,128,0)'];

            const trace = { x: ['1','2','3','4','5'], y: counts, type: 'bar',
                marker: { color: colors, line: { color: 'black', width: 1 } } };

            const layout = { xaxis:{ title: 'Puntuaci√≥n' }, yaxis:{ title: 'Cantidad de rese√±as' }, showlegend:false, height:400 };
            Plotly.newPlot('histChart', [trace], layout, plotlyConfig);
        }

        function quitarAcentos(str) {
            return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }

        function extraerPalabras(texto) {
            if (!texto) return [];
            const stopwords = new Set(['que','los','las','una','uno','para','con','por','del','este','esta','estos','estas',
                'mas','pero','sus','fue','sido','esta','estan','muy','todo','todos','tiene','tienen',
                'hace','hacer','desde','sobre','como','donde','cuando','quien','cual','entre','sin',
                'hasta','hay','era','son','nos','bien','tan','ese','esa','otro','otra','muy','dale','acerque','mencione']);
            const textoNorm = quitarAcentos(texto.toLowerCase());
            const palabras = textoNorm.match(/\b[a-z]{3,}\b/g) || [];
            return palabras.filter(p => !stopwords.has(p)).map(p => {
                if (p.endsWith('es') && p.length > 4) return p.slice(0, -2);
                if (p.endsWith('s') && p.length > 3) return p.slice(0, -1);
                return p;
            });
        }

        /* ------------------ funci√≥n integrada y completa solicitada ------------------ */
        function crearGraficoPalabras(data) {
            const dataPos = data.filter(r => r.Puntuaci√≥n > 3 && r.Comentario);
            const dataNeg = data.filter(r => r.Puntuaci√≥n < 3 && r.Comentario);

            const palabrasPos = {};
            const palabrasNeg = {};

            dataPos.forEach(r => extraerPalabras(r.Comentario).forEach(p => palabrasPos[p] = (palabrasPos[p]||0)+1));
            dataNeg.forEach(r => extraerPalabras(r.Comentario).forEach(p => palabrasNeg[p] = (palabrasNeg[p]||0)+1));

            // eliminar palabras que aparecen en ambos para evitar ambig√ºedad
            Object.keys(palabrasPos).forEach(p => { if (palabrasNeg[p]) { delete palabrasPos[p]; delete palabrasNeg[p]; } });

            const topN = 7;
            const topPos = Object.entries(palabrasPos).sort((a,b)=>b[1]-a[1]).slice(0,topN);
            const topNeg = Object.entries(palabrasNeg).sort((a,b)=>b[1]-a[1]).slice(0,topN);

            // POSITIVAS: ordenar descendente (mayor -> menor) => m√°s positivas a la IZQUIERDA
            const posSorted = topPos.slice().sort((a,b)=>b[1]-a[1]);

            // NEGATIVAS: ordenar ASCENDENTE (menor -> mayor) => menos negativas cerca del CENTRO, m√°s negativas al EXTREMO DERECHO
            const negSorted = topNeg.slice().sort((a,b)=>a[1]-b[1]);

            // etiquetas: primero positivas (izquierda), luego negativas (derecha)
            const palabras = [...posSorted.map(p => p[0]), ...negSorted.map(p => p[0])];

            // valores: positivas >0 (arriba), negativas como n√∫meros negativos (hacia abajo)
            const valores = [...posSorted.map(p => p[1]), ...negSorted.map(p => -p[1])];

            // ------------------ paleta sutil de 14 pasos (verde -> amarillo -> rojo) ------------------
            function lerp(a,b,t){ return Math.round(a + (b - a) * t); }
            // stops: green RGB(0,128,0) -> yellow RGB(255,255,0) -> red RGB(255,0,0)
            const palette14 = [];
            for (let i=0;i<14;i++){
                const t = i / 13; // 0..1
                let r,g,b;
                if (t <= 0.5){
                    const tLocal = t/0.5;
                    r = lerp(0,255,tLocal);
                    g = lerp(128,255,tLocal);
                    b = 0;
                } else {
                    const tLocal = (t-0.5)/0.5;
                    r = 255;
                    g = lerp(255,0,tLocal);
                    b = 0;
                }
                palette14.push(`rgb(${r}, ${g}, ${b})`);
            }

            // asignar color por posici√≥n (izquierda->derecha) tomando la paleta de 14 pasos.
            // Si hay exactamente 14 palabras, cada una toma un stop.
            // Si hay menos/m√°s, mapeamos proporcionalmente.
            const total = palabras.length || 14;
            const colors = [];
            for (let i=0;i<total;i++){
                // √≠ndice en 0..13
                const idx = palette14.length === 1 ? 0 : Math.round(i * (palette14.length - 1) / (total - 1 || 1));
                colors.push(palette14[idx]);
            }
            // ------------------------------------------------------------------------------------------

            // calcular rango Y para mostrar bien barras arriba y abajo
            const maxPos = posSorted.length ? Math.max(...posSorted.map(p => p[1])) : 1;
            const maxNeg = negSorted.length ? Math.max(...negSorted.map(p => p[1])) : 1;
            const yMax = Math.ceil(maxPos * 1.12) + 1;
            const yMin = - (Math.ceil(maxNeg * 2) + 1);

            const trace = {
                x: palabras,
                y: valores,
                type: 'bar',
                marker: { color: colors, line: { color: 'black', width: 1 } },
                text: valores.map(v => Math.abs(v)),
                textposition: 'outside',
                hoverinfo: 'x+y+text'
            };

            const layout = {
                xaxis: { title: 'Palabras', tickangle: -45, automargin: true },
                yaxis: { title: 'Frecuencia (positivas arriba, negativas abajo)', range: [yMin, yMax], zeroline: true, zerolinewidth: 2 },
                showlegend: false,
                bargap: 0.22,
                height: 500,
                margin: { t: 30, b: 140 }
            };

            Plotly.newPlot('palabrasChart', [trace], layout, plotlyConfig);
        }
        /* ------------------------------------------------------------------------------- */

        // --------- Temporal ----------
        function crearGraficoTemporal(data) {
            // Extraer filas con Fecha
            const rowsWithFecha = data.filter(r => r.Fecha && String(r.Fecha).trim() !== '');
            if (rowsWithFecha.length === 0) {
                document.getElementById('temporalChart').innerHTML = '<p style="text-align:center;color:#999;padding:40px;">No hay datos de fecha disponibles</p>';
                return;
            }

            const grouped = {}; // key YYYY-MM -> array de puntuaciones
            rowsWithFecha.forEach(r => {
                const d = parseFechaToDate(r.Fecha);
                if (!d) return; // ignorar si no parsea
                const ym = dateToYYYYMM(d);
                if (!ym) return;
                if (!grouped[ym]) grouped[ym] = [];
                grouped[ym].push(r.Puntuaci√≥n);
            });

            const meses = Object.keys(grouped).sort(); // YYYY-MM lexicographic ordena correctamente
            if (meses.length === 0) {
                document.getElementById('temporalChart').innerHTML = '<p style="text-align:center;color:#999;padding:40px;">No hay fechas v√°lidas para graficar</p>';
                return;
            }

            const promedios = meses.map(m => {
                const arr = grouped[m];
                return arr.reduce((a,b)=>a+b,0)/arr.length;
            });

            // etiquetas como "Mayo 2024"
            const mesesLabels = meses.map(m => yyyymmToSpanishLabel(m));

            // calcular l√≠mite superior din√°mico (max + 0.5) para dejar espacio arriba
            const maxProm = Math.max(...promedios);
            let maxY = maxProm + 0.5;
                        if (maxY > 6) maxY = maxProm + 0.8; // tope razonable

            const trace = {
                x: mesesLabels,
                y: promedios,
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: 'rgb(102,126,234)', width: 3 },
                marker: { size: 8, color: 'rgb(118,75,162)' }
            };

            const layout = {
                xaxis: { title: 'Mes', tickangle: -45 },
                yaxis: { title: 'Puntuaci√≥n Promedio', range: [0, maxY] },
                height: 400,
                margin: { t: 40, b: 100 }
            };

            Plotly.newPlot('temporalChart', [trace], layout, plotlyConfig);
        }

            function mostrarEjemplos(data){
        // Mezclar rese√±as aleatoriamente
        const mezcladas = data.sort(() => Math.random() - 0.5);

        // Separar por puntuaci√≥n
        const positivas = mezcladas.filter(r => parseFloat(r["Puntuaci√≥n"]) >= 4);
        const negativas = mezcladas.filter(r => parseFloat(r["Puntuaci√≥n"]) <= 2);

        // Tomar algunas al azar
        const tomarEjemplos = (arr, n) => arr.slice(0, Math.min(n, arr.length));

        const posEjemplo = tomarEjemplos(positivas, 3);
        const negEjemplo = tomarEjemplos(negativas, 3);

        // Formato de cada comentario (sin platos recomendados)
            const formatearComentario = r => {
            const claseExtra = r["Puntuaci√≥n"] <= 2 ? "negativo" : "";
            return `
                <div class="comment-card ${claseExtra}">
                    <div class="comment-header">
                        <b>${r.Nombre || "An√≥nimo"}</b> ‚≠ê${r["Puntuaci√≥n"]}
                    </div>
                    <div class="comment-body">${r.Comentario || "(sin comentario)"}</div>
                    <div class="comment-date">${r.Fecha || ""}</div>
                </div>
            `;
        };


        // Mostrar dentro de los cuadros de positivos y negativos
        document.getElementById("comentariosPositivos").innerHTML =
            posEjemplo.length ? posEjemplo.map(formatearComentario).join("") :
            "<p>No hay comentarios positivos.</p>";

        document.getElementById("comentariosNegativos").innerHTML =
            negEjemplo.length ? negEjemplo.map(formatearComentario).join("") :
            "<p>No hay comentarios negativos.</p>";
    }


        function updateRangeUI() {
            if (!minHandle || !maxHandle) return;
            minHandle.value = Math.max(parseInt(minHandle.min,10), parseInt(minHandle.value,10));
            maxHandle.value = Math.min(parseInt(maxHandle.max,10), parseInt(maxHandle.value,10));
            clampHandles();
        }

        // ---------- funciones para elegir aleatorios ----------
        function shuffleInplace(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        function sampleArray(arr, n) {
            const copy = arr.slice();
            shuffleInplace(copy);
            return copy.slice(0, n);
        }

                function renderCommentList(containerId, items, title, emptyMsg) {
            const cont = document.getElementById(containerId);
            if (!items || items.length === 0) {
                cont.innerHTML = `<p style="color:#666; margin:8px 0;">${emptyMsg}</p>`;
                return;
            }
            const isNegatives = title.includes('Negativos');
            let html = `<h3 style="margin-bottom:12px;">${title}</h3>`;
            items.forEach(r => {
                const cls = isNegatives ? 'negativo' : '';
                html += `
                    <div class="comment-card ${cls}">
                        <div class="comment-header">
                            <span>‚≠ê ${r.Puntuaci√≥n} - ${r.Nombre || 'An√≥nimo'}</span>
                            <span>${r.Fecha || ''}</span>
                        </div>
                        <div class="comment-text">${r.Comentario || ''}</div>
                        ${r['Platos recomendados'] ? `<div class="comment-meta">üçΩÔ∏è ${r['Platos recomendados']}</div>` : ''}
                    </div>
                `;
            });
            cont.innerHTML = html;
        }


        // Botones: usar FILTRADO actual, si no alcanza, completar desde dataGlobal
        document.addEventListener('click', function(e) {
            if (e.target && e.target.id === 'randomPosBtn') {
                const filtered = filtrarDatos();
                let pool = filtered.filter(r => r.Puntuaci√≥n >= 4 && r.Comentario);
                let fallbackNote = '';
                if (pool.length < 3) {
                    const need = 3 - pool.length;
                    const fromFull = dataGlobal.filter(r => r.Puntuaci√≥n >= 4 && r.Comentario && !pool.includes(r));
                    pool = pool.concat(sampleArray(fromFull, need));
                    fallbackNote = pool.length < 3 ? ' (no hay suficientes en el dataset)' : ' (completo desde dataset completo)';
                }
                const chosen = sampleArray(pool, Math.min(3, pool.length));
                renderCommentList('randomPosContainer', chosen, '‚ú® 3 Comentarios Positivos Aleatorios', 'No hay comentarios positivos disponibles en el filtro o dataset.');
                if (fallbackNote) {
                    const note = document.createElement('div');
                    note.style.color = '#666';
                    note.style.marginTop = '6px';
                    note.textContent = fallbackNote;
                    document.getElementById('randomPosContainer').appendChild(note);
                }
            }
            if (e.target && e.target.id === 'randomNegBtn') {
                const filtered = filtrarDatos();
                let pool = filtered.filter(r => r.Puntuaci√≥n <= 2 && r.Comentario);
                let fallbackNote = '';
                if (pool.length < 3) {
                    const need = 3 - pool.length;
                    const fromFull = dataGlobal.filter(r => r.Puntuaci√≥n <= 2 && r.Comentario && !pool.includes(r));
                    pool = pool.concat(sampleArray(fromFull, need));
                    fallbackNote = pool.length < 3 ? ' (no hay suficientes en el dataset)' : ' (completo desde dataset completo)';
                }
                const chosen = sampleArray(pool, Math.min(3, pool.length));
                renderCommentList('randomNegContainer', chosen, '‚ö†Ô∏è 3 Comentarios Negativos Aleatorios', 'No hay comentarios negativos disponibles en el filtro o dataset.');
                if (fallbackNote) {
                    const note = document.createElement('div');
                    note.style.color = '#666';
                    note.style.marginTop = '6px';
                    note.textContent = fallbackNote;
                    document.getElementById('randomNegContainer').appendChild(note);
                }
            }
        });

    </script>
</body>
</html>
